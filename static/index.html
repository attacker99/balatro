<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Balatro simulations</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <h1>simulate Balatro discard/draw</h1>
    <div class="container">
        <div class="top-sections">
            <div class="deck-section">
                <h2>deck builder</h2>
                <div class="deck-info">
                    <p>format: [{rank: 2-9,TJQKA}{suit: shdc}][enhancement][edition][seal][quantity]</p>
                    <p>stone format: s[enhancement][edition][seal][quantity]</p>
                    <p>enhancements: b(bonus) m(mult) w(wild) g(glass) s(steel) y(gold) l(lucky)</p>
                    <p>editions: f(foil) h(holographic) p(polychrome)</p>
                    <p>seals: y(gold) r(red) b(blue) p(purple)</p>
                    <p>example: Ac Kd2 Th1 s20 Acgfr17 3sghp5 s20fy</p>
                </div>
                <div class="deck-input-group">
                    <input type="text" class="deck-input" placeholder="enter cards to add (e.g., 'Ac Kd2 Ts1 s20')" 
                           onkeypress="if(event.key === 'Enter') addToDeck()">
                    <div class="button-container">
                        <button onclick="addToDeck()">add</button>
                    </div>
                </div>
                <div class="deck-input-group">
                    <input type="text" class="deck-remove-input" placeholder="enter cards to remove (e.g., 'Ac Kd2 Ts1 s20')" 
                           onkeypress="if(event.key === 'Enter') removeFromDeck()">
                    <div class="button-container">
                        <button onclick="removeFromDeck()">remove</button>
                    </div>
                </div>
                <div class="deck-controls">
                    <button onclick="buildStandardDeck()">build standard</button>
                    <button onclick="buildCheckeredDeck()">build checkered</button>
                    <button onclick="buildAbandonedDeck()">build abandoned</button>
                    <button onclick="clearDeck()">clear</button>
                </div>
                <h3>available cards</h3>
                <div id="deck" class="card-container"></div>
            </div>
            <div class="hand-section">
                <h2>build hand (subset of deck)</h2>
                <div class="hand-controls">
                    <input type="text" class="hand-input" placeholder="enter cards (e.g., 'Ac Kd2 Ts1')" 
                           onkeypress="if(event.key === 'Enter') buildHandFromText(false)">
                </div>
                <div class="hand-controls button-row">
                    <button onclick="buildHandFromText(false)">add</button>
                    <button onclick="buildHandFromText(true)">build new</button>
                    <button onclick="clearHand()">clear</button>
                </div>
                <div class="hand-controls">
                    <label>size: <input type="number" id="hand-fs-sz" min="1" max="5" value="4"></label>
                    <label>dist: <input type="number" id="hand-dist" min="1" max="2" value="1"></label>
                    <button onclick="evaluateHand()">evaluate</button>
                </div>
                <div id="hand-error" class="error-message"></div>
                <div class="hand-info">
                    <p>click on cards to mark them for discard</p>
                </div>
                <div id="hand" class="card-container"></div>
                <div id="result" class="result"></div>
            </div>
        </div>
        <div class="sim-section">
            <h2>simulation</h2>
            <div class="sim-controls">
                <label>draw: <input type="number" id="draw-num" min="1" value="5"></label>
                <label>size: <input type="number" id="fs-sz" min="1" value="5"></label>
                <label>dist: <input type="number" id="dist" min="1" value="1"></label>
                <label>simulations: <input type="number" id="num-sims" min="1" value="1000"></label>
                <label><input type="checkbox" id="enable-logging"> enable logging</label>
                <button onclick="simulate()">simulate</button>
            </div>
            <div id="sim-result" class="sim-result"></div>
            <div id="sim-stats" class="sim-stats">
                <div class="stats-section">
                    <h3>Enhancement Statistics</h3>
                    <div id="enhancement-stats"></div>
                </div>
                <div class="stats-section">
                    <h3>Edition Statistics</h3>
                    <div id="edition-stats"></div>
                </div>
                <div class="stats-section">
                    <h3>Seal Statistics</h3>
                    <div id="seal-stats"></div>
                </div>
            </div>
        </div>
    </div>
    <script>
        // Global variables
        let deck = new Map(); // Map of cardId -> {rank, suit, quantity, enhancement, edition, seal}
        let selectedCards = new Map(); // Map of cardId -> quantity
        let selectedForDiscard = new Set(); // Set of cardIds selected for discard

        // Card parsing functions
        function parseCardSpec(spec) {
            console.log('Parsing spec:', spec);
            
            // Handle stone cards
            if (spec.startsWith('s')) {
                console.log('Matched stone card');
                let remainingSpec = spec.slice(1);
                let quantity = 1;
                let edition = 'Base';
                let seal = null;
                
                // Extract quantity if present at start
                const quantityMatch = remainingSpec.match(/^(\d+)/);
                if (quantityMatch) {
                    quantity = parseInt(quantityMatch[1]);
                    remainingSpec = remainingSpec.slice(quantityMatch[0].length);
                    console.log('Matched quantity:', quantity);
                }

                // Parse edition
                if (remainingSpec.length > 0) {
                    const edCode = remainingSpec[0].toLowerCase();
                    const edMap = {
                        'f': 'Foil',
                        'h': 'Holographic',
                        'p': 'Polychrome',
                        'n': 'Base'
                    };
                    edition = edMap[edCode] || 'Base';
                    remainingSpec = remainingSpec.slice(1);
                    console.log('Matched edition:', edition);
                }

                // Parse seal
                if (remainingSpec.length > 0) {
                    const sealCode = remainingSpec[0].toLowerCase();
                    const sealMap = {
                        'y': 'Gold',
                        'r': 'Red',
                        'b': 'Blue',
                        'p': 'Purple',
                        'n': null
                    };
                    seal = sealMap[sealCode] || null;
                    console.log('Matched seal:', seal);
                }

                // If quantity wasn't at start, check for it at end
                if (!quantityMatch && remainingSpec.length > 0) {
                    const endQuantityMatch = remainingSpec.match(/(\d+)$/);
                    if (endQuantityMatch) {
                        quantity = parseInt(endQuantityMatch[1]);
                        remainingSpec = remainingSpec.slice(0, -endQuantityMatch[0].length);
                        console.log('Matched quantity at end:', quantity);
                    }
                }

                return {
                    rank: 'S',
                    suit: 'S',
                    enhancement: 'Stone',
                    edition,
                    seal,
                    quantity
                };
            }

            // Parse regular cards
            const rankMatch = spec.match(/^([A2-9TJQK])/i);
            if (!rankMatch) {
                console.log('Failed to match rank. Spec:', spec);
                return null;
            }
            const rank = rankMatch[1].toUpperCase();
            console.log('Matched rank:', rank);

            const suitMatch = spec.match(/^[A2-9TJQK]([shdc])/i);
            if (!suitMatch) {
                console.log('Failed to match suit. Spec:', spec);
                return null;
            }
            const suit = suitMatch[1].toLowerCase();
            console.log('Matched suit:', suit);

            // Remove rank and suit from spec
            let remainingSpec = spec.slice(2);
            console.log('Remaining spec after rank/suit:', remainingSpec);

            // Extract quantity if present
            let quantity = 1;
            const quantityMatch = remainingSpec.match(/^(\d+)/);
            if (quantityMatch) {
                quantity = parseInt(quantityMatch[1]);
                remainingSpec = remainingSpec.slice(quantityMatch[0].length);
                console.log('Matched quantity:', quantity);
            }

            // Parse enhancement
            let enhancement = 'None';
            if (remainingSpec.length > 0) {
                const enhCode = remainingSpec[0].toLowerCase();
                const enhMap = {
                    'b': 'Bonus',
                    'm': 'Mult',
                    'w': 'Wild',
                    'g': 'Glass',
                    's': 'Steel',
                    'y': 'Gold',
                    'l': 'Lucky',
                    'n': 'None'
                };
                enhancement = enhMap[enhCode] || 'None';
                remainingSpec = remainingSpec.slice(1);
                console.log('Matched enhancement:', enhancement);
            }

            // Parse edition
            let edition = 'Base';
            if (remainingSpec.length > 0) {
                const edCode = remainingSpec[0].toLowerCase();
                const edMap = {
                    'f': 'Foil',
                    'h': 'Holographic',
                    'p': 'Polychrome',
                    'n': 'Base'
                };
                edition = edMap[edCode] || 'Base';
                remainingSpec = remainingSpec.slice(1);
                console.log('Matched edition:', edition);
            }

            // Parse seal
            let seal = null;
            if (remainingSpec.length > 0) {
                const sealCode = remainingSpec[0].toLowerCase();
                const sealMap = {
                    'y': 'Gold',
                    'r': 'Red',
                    'b': 'Blue',
                    'p': 'Purple',
                    'n': null
                };
                seal = sealMap[sealCode] || null;
                console.log('Matched seal:', seal);
            }

            return {
                rank,
                suit,
                enhancement,
                edition,
                seal,
                quantity
            };
        }

        function parseCardsWithQuantity(input) {
            console.log('Parsing input:', input);
            const specs = input.split(/\s+/);
            const cards = [];
            
            for (const spec of specs) {
                if (!spec) continue;
                
                console.log('Processing spec:', spec);
                const card = parseCardSpec(spec);
                if (card) {
                    console.log('Successfully parsed card:', card);
                    // Instead of creating multiple cards, create one card with the quantity
                    cards.push({
                        rank: card.rank,
                        suit: card.suit,
                        enhancement: card.enhancement,
                        edition: card.edition,
                        seal: card.seal,
                        quantity: card.quantity
                    });
                } else {
                    console.error('Failed to parse card spec:', spec);
                }
            }
            
            console.log('Final cards array:', cards);
            return cards;
        }

        // Card display functions
        function createCardElement(card) {
            const cardDiv = document.createElement('div');
            cardDiv.className = 'card';
            
            // Handle stone cards differently
            if (card.rank === 'S' && card.suit === 'S') {
                cardDiv.classList.add('stone');
                
                // Add edition indicator first (top left)
                if (card.edition && card.edition !== 'Base') {
                    const edition = document.createElement('div');
                    edition.className = `edition ${card.edition.toLowerCase()}`;
                    cardDiv.appendChild(edition);
                }

                // Always add quantity indicator (top right)
                const quantityDiv = document.createElement('div');
                quantityDiv.className = 'quantity';
                quantityDiv.textContent = card.quantity;
                cardDiv.appendChild(quantityDiv);

                // Add seal indicator (bottom right)
                if (card.seal) {
                    const seal = document.createElement('div');
                    seal.className = `seal ${card.seal.toLowerCase()}`;
                    cardDiv.appendChild(seal);
                }

                return cardDiv;
            }
            
            // Regular card content
            const content = document.createElement('div');
            content.className = 'card-content';
            
            const rankSpan = document.createElement('span');
            rankSpan.className = 'rank';
            rankSpan.textContent = card.rank;
            content.appendChild(rankSpan);
            
            const suitSpan = document.createElement('span');
            suitSpan.className = 'suit';
            // Convert suit code to symbol
            const suitSymbol = card.suit === 's' ? '♠' : 
                             card.suit === 'h' ? '♥' : 
                             card.suit === 'd' ? '♦' : '♣';
            suitSpan.textContent = suitSymbol;
            content.appendChild(suitSpan);
            
            cardDiv.appendChild(content);

            // Add enhancement indicator
            if (card.enhancement && card.enhancement !== 'None') {
                const enhancement = document.createElement('div');
                enhancement.className = `enhancement ${card.enhancement.toLowerCase()}`;
                cardDiv.appendChild(enhancement);
            }

            // Add edition indicator
            if (card.edition && card.edition !== 'Base') {
                const edition = document.createElement('div');
                edition.className = `edition ${card.edition.toLowerCase()}`;
                cardDiv.appendChild(edition);
            }

            // Add seal indicator
            if (card.seal) {
                const seal = document.createElement('div');
                seal.className = `seal ${card.seal.toLowerCase()}`;
                cardDiv.appendChild(seal);
            }
            
            return cardDiv;
        }

        function displayCards(container, cards) {
            container.innerHTML = '';
            cards.forEach(card => {
                const cardElement = createCardElement(card);
                
                // Add quantity indicator
                if (card.quantity > 1) {
                    const quantityDiv = document.createElement('div');
                    quantityDiv.className = 'quantity';
                    quantityDiv.textContent = card.quantity;
                    cardElement.appendChild(quantityDiv);
                }
                
                container.appendChild(cardElement);
            });
        }

        // Deck management functions
        function getCardId(card) {
            return `${card.rank}${card.suit}${card.enhancement !== 'None' ? card.enhancement : ''}${card.edition !== 'Base' ? card.edition : ''}${card.seal || ''}`;
        }

        function addToDeck() {
            const input = document.querySelector('.deck-input');
            const spec = input.value.trim();
            if (!spec) return;

            console.log('Adding cards with spec:', spec);
            const cards = parseCardsWithQuantity(spec);
            console.log('Parsed cards:', cards);
            
            if (cards.length > 0) {
                // Add new cards to deck
                cards.forEach(card => {
                    const cardId = getCardId(card);
                    const existingCard = deck.get(cardId);
                    if (existingCard) {
                        existingCard.quantity += card.quantity;
                    } else {
                        deck.set(cardId, { ...card });
                    }
                });

                // Update display
                renderDeck();
                input.value = '';
            } else {
                console.error('No cards were parsed from spec:', spec);
            }
        }

        function removeFromDeck() {
            const input = document.querySelector('.deck-remove-input');
            const spec = input.value.trim();
            if (!spec) return;

            console.log('Removing cards with spec:', spec);
            const cards = parseCardsWithQuantity(spec);
            console.log('Parsed cards to remove:', cards);
            
            if (cards.length > 0) {
                // TODO: Implement actual removal logic
                displayCards(document.getElementById('deck'), cards);
                input.value = '';
            } else {
                console.error('No cards were parsed from spec:', spec);
            }
        }

        function buildStandardDeck() {
            // Clear all state
            deck.clear();
            selectedCards.clear();
            selectedForDiscard.clear();
            
            // Clear all inputs and results
            document.querySelector('.deck-input').value = '';
            document.querySelector('.hand-input').value = '';
            document.getElementById('hand-error').textContent = '';
            document.getElementById('result').innerHTML = '';
            document.getElementById('sim-result').innerHTML = '';
            
            // Create standard deck
            const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K'];
            const suits = ['s', 'h', 'd', 'c'];
            
            ranks.forEach(rank => {
                suits.forEach(suit => {
                    const card = {
                        rank,
                        suit,
                        enhancement: 'None',
                        edition: 'Base',
                        seal: null,
                        quantity: 1
                    };
                    const cardId = getCardId(card);
                    deck.set(cardId, card);
                });
            });
            
            // Update UI
            renderDeck();
            renderHand();
        }

        function buildCheckeredDeck() {
            // Clear all state
            deck.clear();
            selectedCards.clear();
            selectedForDiscard.clear();
            
            // Clear all inputs and results
            document.querySelector('.deck-input').value = '';
            document.querySelector('.hand-input').value = '';
            document.getElementById('hand-error').textContent = '';
            document.getElementById('result').innerHTML = '';
            document.getElementById('sim-result').innerHTML = '';
            
            // Create checkered deck (only spades and hearts)
            const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K'];
            const suits = ['s', 'h'];
            
            ranks.forEach(rank => {
                suits.forEach(suit => {
                    const card = {
                        rank,
                        suit,
                        enhancement: 'None',
                        edition: 'Base',
                        seal: null,
                        quantity: 1
                    };
                    const cardId = getCardId(card);
                    deck.set(cardId, card);
                });
            });
            
            // Update UI
            renderDeck();
            renderHand();
        }

        function buildAbandonedDeck() {
            // Clear all state
            deck.clear();
            selectedCards.clear();
            selectedForDiscard.clear();
            
            // Clear all inputs and results
            document.querySelector('.deck-input').value = '';
            document.querySelector('.hand-input').value = '';
            document.getElementById('hand-error').textContent = '';
            document.getElementById('result').innerHTML = '';
            document.getElementById('sim-result').innerHTML = '';
            
            // Create abandoned deck (no face cards)
            const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', 'T'];
            const suits = ['s', 'h', 'd', 'c'];
            
            ranks.forEach(rank => {
                suits.forEach(suit => {
                    const card = {
                        rank,
                        suit,
                        enhancement: 'None',
                        edition: 'Base',
                        seal: null,
                        quantity: 1
                    };
                    const cardId = getCardId(card);
                    deck.set(cardId, card);
                });
            });            
            renderDeck();
            renderHand();
        }

        function addCard(cardId) {
            const card = deck.get(cardId);
            if (card) {
                card.quantity++;
                renderDeck();
            }
        }

        function removeCard(cardId) {
            const card = deck.get(cardId);
            if (card) {
                if (card.quantity > 1) {
                    card.quantity--;
                } else {
                    deck.delete(cardId);
                }
                renderDeck();
            }
        }

        function clearDeck() {
            deck.clear();
            selectedCards.clear();
            selectedForDiscard.clear();
            document.querySelector('.deck-input').value = '';
            document.querySelector('.hand-input').value = '';
            document.getElementById('hand-error').textContent = '';
            document.getElementById('result').innerHTML = '';
            document.getElementById('sim-result').innerHTML = '';
            renderDeck();
            renderHand();
        }

        function toggleCardForDiscard(cardId) {
            if (selectedForDiscard.has(cardId)) {
                selectedForDiscard.delete(cardId);
            } else {
                selectedForDiscard.add(cardId);
            }
            renderHand();
        }

        function renderDeck() {
            const deckElement = document.getElementById('deck');
            deckElement.innerHTML = '';
            
            // Sort cards by rank and suit for consistent display
            const sortedCards = Array.from(deck.values()).sort((a, b) => {
                const rankOrder = { 'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, 'T': 10, 'J': 11, 'Q': 12, 'K': 13, 'S': 14 };
                const suitOrder = { 's': 0, 'h': 1, 'd': 2, 'c': 3, 'S': 4 };
                
                if (a.rank !== b.rank) {
                    return rankOrder[a.rank] - rankOrder[b.rank];
                }
                return suitOrder[a.suit] - suitOrder[b.suit];
            });
            
            sortedCards.forEach(card => {
                const cardElement = document.createElement('div');
                cardElement.className = 'card';
                
                // Handle stone cards differently
                if (card.rank === 'S' && card.suit === 'S') {
                    cardElement.classList.add('stone');
                    
                    // Add edition indicator first (top left)
                    if (card.edition && card.edition !== 'Base') {
                        const edition = document.createElement('div');
                        edition.className = `edition ${card.edition.toLowerCase()}`;
                        cardElement.appendChild(edition);
                    }

                    // Always add quantity indicator (top right)
                    const quantityDiv = document.createElement('div');
                    quantityDiv.className = 'quantity';
                    quantityDiv.textContent = card.quantity;
                    cardElement.appendChild(quantityDiv);

                    // Add seal indicator (bottom right)
                    if (card.seal) {
                        const seal = document.createElement('div');
                        seal.className = `seal ${card.seal.toLowerCase()}`;
                        cardElement.appendChild(seal);
                    }
                } else {
                    // Regular card content
                    const content = document.createElement('div');
                    content.className = 'card-content';
                    
                    const rankSpan = document.createElement('span');
                    rankSpan.className = 'rank';
                    rankSpan.textContent = card.rank;
                    content.appendChild(rankSpan);
                    
                    const suitSpan = document.createElement('span');
                    suitSpan.className = 'suit';
                    const suitSymbol = card.suit === 's' ? '♠' : 
                                     card.suit === 'h' ? '♥' : 
                                     card.suit === 'd' ? '♦' : '♣';
                    suitSpan.textContent = suitSymbol;
                    content.appendChild(suitSpan);
                    
                    // Set color based on suit
                    if (card.suit === 'h' || card.suit === 'd') {
                        content.style.color = 'red';
                    }
                    
                    cardElement.appendChild(content);

                    // Add enhancement indicator
                    if (card.enhancement && card.enhancement !== 'None') {
                        const enhancement = document.createElement('div');
                        enhancement.className = `enhancement ${card.enhancement.toLowerCase()}`;
                        cardElement.appendChild(enhancement);
                    }

                    // Add edition indicator
                    if (card.edition && card.edition !== 'Base') {
                        const edition = document.createElement('div');
                        edition.className = `edition ${card.edition.toLowerCase()}`;
                        cardElement.appendChild(edition);
                    }

                    // Add seal indicator
                    if (card.seal) {
                        const seal = document.createElement('div');
                        seal.className = `seal ${card.seal.toLowerCase()}`;
                        cardElement.appendChild(seal);
                    }

                    // Add quantity indicator for regular cards
                    if (card.quantity > 1) {
                        const quantityDiv = document.createElement('div');
                        quantityDiv.className = 'quantity';
                        quantityDiv.textContent = card.quantity;
                        cardElement.appendChild(quantityDiv);
                    }
                }

                // Add card controls (bottom center)
                const controls = document.createElement('div');
                controls.className = 'card-controls';
                controls.innerHTML = `
                    <button onclick="event.stopPropagation(); addCard('${getCardId(card)}')">+</button>
                    <button onclick="event.stopPropagation(); removeCard('${getCardId(card)}')">-</button>
                `;
                cardElement.appendChild(controls);
                
                deckElement.appendChild(cardElement);
            });
        }

        function buildHandFromText(isNewHand) {
            const input = document.querySelector('.hand-input');
            const spec = input.value.trim();
            if (!spec) return;

            console.log('Building hand with spec:', spec);
            const cards = parseCardsWithQuantity(spec);
            console.log('Parsed cards for hand:', cards);
            
            if (cards.length > 0) {
                // If building a new hand, return current cards to deck first
                if (isNewHand) {
                    selectedCards.forEach((card, cardId) => {
                        const baseCardId = getCardId(card);
                        const deckCard = deck.get(baseCardId);
                        if (deckCard) {
                            deckCard.quantity++;
                        } else {
                            deck.set(baseCardId, { ...card, quantity: 1 });
                        }
                    });
                    selectedCards.clear();
                    selectedForDiscard.clear();
                }
                
                cards.forEach(card => {
                    const cardId = getCardId(card);
                    const deckCard = deck.get(cardId);
                    
                    if (deckCard && deckCard.quantity >= card.quantity) {
                        // Update deck quantity
                        deckCard.quantity -= card.quantity;
                        if (deckCard.quantity === 0) {
                            deck.delete(cardId);
                        }
                        
                        // Add individual cards to hand
                        for (let i = 0; i < card.quantity; i++) {
                            const individualCardId = `${cardId}_${i}`;
                            selectedCards.set(individualCardId, {
                                ...card,
                                quantity: 1
                            });
                        }
                    } else {
                        console.error('Not enough cards in deck:', cardId);
                    }
                });
                
                // Update both deck and hand displays
                renderDeck();
                renderHand();
                input.value = '';
            } else {
                console.error('No cards were parsed from spec:', spec);
            }
        }

        function renderHand() {
            const handElement = document.getElementById('hand');
            handElement.innerHTML = '';
            
            selectedCards.forEach((card, cardId) => {
                const isDiscard = selectedForDiscard.has(cardId);
                const cardElement = document.createElement('div');
                cardElement.className = `card ${isDiscard ? 'selected-for-discard' : 'selected'}`;
                
                // Handle stone cards differently
                if (card.rank === 'S' && card.suit === 'S') {
                    cardElement.classList.add('stone');
                    
                    // Add edition indicator first (top left)
                    if (card.edition && card.edition !== 'Base') {
                        const edition = document.createElement('div');
                        edition.className = `edition ${card.edition.toLowerCase()}`;
                        cardElement.appendChild(edition);
                    }

                    // Always add quantity indicator (top right)
                    const quantityDiv = document.createElement('div');
                    quantityDiv.className = 'quantity';
                    quantityDiv.textContent = card.quantity;
                    cardElement.appendChild(quantityDiv);

                    // Add seal indicator (bottom right)
                    if (card.seal) {
                        const seal = document.createElement('div');
                        seal.className = `seal ${card.seal.toLowerCase()}`;
                        cardElement.appendChild(seal);
                    }
                } else {
                    // Regular card content
                    const content = document.createElement('div');
                    content.className = 'card-content';
                    
                    const rankSpan = document.createElement('span');
                    rankSpan.className = 'rank';
                    rankSpan.textContent = card.rank;
                    content.appendChild(rankSpan);
                    
                    const suitSpan = document.createElement('span');
                    suitSpan.className = 'suit';
                    const suitSymbol = card.suit === 's' ? '♠' : 
                                     card.suit === 'h' ? '♥' : 
                                     card.suit === 'd' ? '♦' : '♣';
                    suitSpan.textContent = suitSymbol;
                    content.appendChild(suitSpan);
                    
                    // Set color based on suit
                    if (card.suit === 'h' || card.suit === 'd') {
                        content.style.color = 'red';
                    }
                    
                    cardElement.appendChild(content);

                    // Add enhancement indicator
                    if (card.enhancement && card.enhancement !== 'None') {
                        const enhancement = document.createElement('div');
                        enhancement.className = `enhancement ${card.enhancement.toLowerCase()}`;
                        cardElement.appendChild(enhancement);
                    }

                    // Add edition indicator
                    if (card.edition && card.edition !== 'Base') {
                        const edition = document.createElement('div');
                        edition.className = `edition ${card.edition.toLowerCase()}`;
                        cardElement.appendChild(edition);
                    }

                    // Add seal indicator
                    if (card.seal) {
                        const seal = document.createElement('div');
                        seal.className = `seal ${card.seal.toLowerCase()}`;
                        cardElement.appendChild(seal);
                    }

                    // Add quantity indicator for regular cards
                    if (card.quantity > 1) {
                        const quantityDiv = document.createElement('div');
                        quantityDiv.className = 'quantity';
                        quantityDiv.textContent = card.quantity;
                        cardElement.appendChild(quantityDiv);
                    }
                }

                // Add card controls
                const controls = document.createElement('div');
                controls.className = 'card-controls';
                controls.innerHTML = `
                    <button onclick="event.stopPropagation(); returnCardToDeck('${cardId}')">×</button>
                `;
                cardElement.appendChild(controls);
                
                cardElement.onclick = () => toggleCardForDiscard(cardId);
                handElement.appendChild(cardElement);
            });
        }

        function clearHand() {
            // Return cards to deck
            selectedCards.forEach((card, individualCardId) => {
                const baseCardId = getCardId(card);
                const deckCard = deck.get(baseCardId);
                if (deckCard) {
                    deckCard.quantity++;
                } else {
                    deck.set(baseCardId, { ...card, quantity: 1 });
                }
            });
            
            selectedCards.clear();
            selectedForDiscard.clear();
            document.querySelector('.hand-input').value = '';
            document.getElementById('hand-error').textContent = '';
            document.getElementById('result').innerHTML = '';
            document.getElementById('sim-result').innerHTML = '';
            renderDeck();
            renderHand();
        }

        function returnCardToDeck(cardId) {
            const card = selectedCards.get(cardId);
            if (card) {
                // Remove from discard selection if it was marked
                selectedForDiscard.delete(cardId);
                
                // Return card to deck
                const baseCardId = getCardId(card);
                const deckCard = deck.get(baseCardId);
                if (deckCard) {
                    deckCard.quantity++;
                } else {
                    deck.set(baseCardId, { ...card, quantity: 1 });
                }
                
                // Remove from hand
                selectedCards.delete(cardId);
                
                // Update displays
                renderDeck();
                renderHand();
            }
        }

        async function evaluateHand() {
            const cards = [];
            selectedCards.forEach((card, cardId) => {
                if (!selectedForDiscard.has(cardId)) {
                    if (card.rank === 'S' && card.suit === 'S') {
                        // Handle stone cards
                        cards.push({
                            rank: 'S',
                            suit: 'S',
                            enhancement: 'Stone',
                            edition: card.edition,
                            seal: card.seal
                        });
                    } else {
                        // Handle regular cards
                        cards.push({
                            rank: card.rank.toLowerCase(),
                            suit: card.suit.toLowerCase(),
                            enhancement: card.enhancement,
                            edition: card.edition,
                            seal: card.seal
                        });
                    }
                }
            });

            const fsSz = parseInt(document.getElementById('hand-fs-sz').value) || 5;
            const dist = parseInt(document.getElementById('hand-dist').value) || 1;

            const requestBody = {
                cards: cards,
                size: fsSz,
                distance: dist
            };

            // Log the exact request being sent
            console.log('Sending evaluate request:', {
                requestBody: requestBody,
                stringified: JSON.stringify(requestBody),
                cards: cards.map(c => `${c.rank}${c.suit}`).join(' '),
                rawCards: cards
            });

            try {
                const response = await fetch('http://localhost:3000/api/evaluate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Server response:', errorText);
                    throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
                }

                const result = await response.json();
                if (!result.handType) {
                    throw new Error('Invalid response format: missing handType');
                }

                document.getElementById('result').innerHTML = `
                    <h3>Hand Type: ${result.handType}</h3>
                    <p>Cards in Hand: ${cards.length}</p>
                    <p>Cards Marked for Discard: ${selectedForDiscard.size}</p>
                `;
            } catch (error) {
                console.error('Error:', error);
                document.getElementById('result').innerHTML = `
                    <div class="error-message">Error: ${error.message}</div>
                `;
            }
        }

        async function simulate() {
            const drawNum = parseInt(document.getElementById('draw-num').value) || 5;
            const fsSz = parseInt(document.getElementById('fs-sz').value) || 5;
            const dist = parseInt(document.getElementById('dist').value) || 1;
            const numSims = parseInt(document.getElementById('num-sims').value) || 1000;

            // Initialize statistics
            const stats = {
                handTypes: {
                    'High Card': 0,
                    'Pair': 0,
                    'Two Pair': 0,
                    'Three of a Kind': 0,
                    'Straight': 0,
                    'Flush': 0,
                    'Full House': 0,
                    'Four of a Kind': 0,
                    'Straight Flush': 0,
                    'Royal Flush': 0,
                    'Flush House': 0
                },
                enhancements: {
                    'None': 0,
                    'Bonus': 0,
                    'Mult': 0,
                    'Wild': 0,
                    'Glass': 0,
                    'Steel': 0,
                    'Gold': 0,
                    'Lucky': 0,
                    'Stone': 0
                },
                editions: {
                    'Base': 0,
                    'Foil': 0,
                    'Holographic': 0,
                    'Polychrome': 0
                },
                seals: {
                    'None': 0,
                    'Gold': 0,
                    'Red': 0,
                    'Blue': 0,
                    'Purple': 0
                },
                totalCards: 0  // Track total number of cards across all hands
            };

            let totalSims = 0;

            // Convert deck Map to string format
            const deckString = Array.from(deck.values())
                .map(card => {
                    let spec = card.rank + card.suit;
                    if (card.enhancement !== 'None') spec += card.enhancement[0].toLowerCase();
                    if (card.edition !== 'Base') spec += card.edition[0].toLowerCase();
                    if (card.seal) spec += card.seal[0].toLowerCase();
                    if (card.quantity > 1) spec += card.quantity;
                    return spec;
                })
                .join(' ');

            // Convert selected cards to string format
            const handString = Array.from(selectedCards.values())
                .map(card => {
                    let spec = card.rank + card.suit;
                    if (card.enhancement !== 'None') spec += card.enhancement[0].toLowerCase();
                    if (card.edition !== 'Base') spec += card.edition[0].toLowerCase();
                    if (card.seal) spec += card.seal[0].toLowerCase();
                    return spec;
                })
                .join(' ');

            // Convert discarded cards to string format
            const discardString = Array.from(selectedForDiscard)
                .map(cardId => {
                    const card = selectedCards.get(cardId);
                    if (!card) return '';
                    let spec = card.rank + card.suit;
                    if (card.enhancement !== 'None') spec += card.enhancement[0].toLowerCase();
                    if (card.edition !== 'Base') spec += card.edition[0].toLowerCase();
                    if (card.seal) spec += card.seal[0].toLowerCase();
                    return spec;
                })
                .filter(spec => spec !== '')
                .join(' ');

            const enableLogging = document.getElementById('enable-logging').checked;
            if (enableLogging) {
                console.log('Sending simulation request:', {
                    deck: deckString,
                    hand: handString,
                    discard: discardString,
                    drawNum,
                    fsSz,
                    dist,
                    numSims: 1
                });
            }

            try {
                // Run multiple simulations
                for (let i = 0; i < numSims; i++) {
                    const response = await fetch('http://localhost:3000/api/simulate', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            deck: deckString,
                            hand: handString,
                            discard: discardString,
                            drawNum,
                            fsSz,
                            dist,
                            numSims: 1,
                            enableLogging
                        })
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
                    }

                    const result = await response.json();
                    if (enableLogging) {
                        console.log('Server response:', result);
                    }
                    
                    if (!result.handType) {
                        throw new Error('Invalid response format: missing handType');
                    }

                    totalSims++;
                    
                    // Update hand type statistics
                    stats.handTypes[result.handType] = (stats.handTypes[result.handType] || 0) + 1;
                    
                    // Update statistics for all cards in the hand
                    if (result.drawnCards && Array.isArray(result.drawnCards)) {
                        // Count cards in the drawn cards
                        result.drawnCards.forEach(card => {
                            stats.totalCards++;
                            
                            // Handle enhancement
                            if (card.enhancement) {
                                const enhType = card.enhancement === 'None' ? 'None' : card.enhancement;
                                stats.enhancements[enhType] = (stats.enhancements[enhType] || 0) + 1;
                            } else {
                                stats.enhancements['None'] = (stats.enhancements['None'] || 0) + 1;
                            }

                            // Handle edition
                            if (card.edition) {
                                const edType = card.edition === 'Base' ? 'Base' : card.edition;
                                stats.editions[edType] = (stats.editions[edType] || 0) + 1;
                            } else {
                                stats.editions['Base'] = (stats.editions['Base'] || 0) + 1;
                            }

                            // Handle seal
                            if (card.seal) {
                                const sealType = card.seal;
                                stats.seals[sealType] = (stats.seals[sealType] || 0) + 1;
                            } else {
                                stats.seals['None'] = (stats.seals['None'] || 0) + 1;
                            }
                        });
                    }
                }

                // Update simulation results
                document.getElementById('sim-result').innerHTML = `
                    <h3>Hand Type Distribution</h3>
                    <table class="stats-table">
                        <tr><th>Hand Type</th><th>Count</th><th>% of Hands</th></tr>
                        ${Object.entries(stats.handTypes)
                            .filter(([_, count]) => count > 0)
                            .sort((a, b) => b[1] - a[1])  // Sort by count descending
                            .map(([type, count]) => `
                                <tr>
                                    <td>${type}</td>
                                    <td>${count}</td>
                                    <td>${((count / totalSims) * 100).toFixed(2)}%</td>
                                </tr>
                            `).join('')}
                    </table>
                `;

                // Update enhancement statistics
                document.getElementById('enhancement-stats').innerHTML = `
                    <h3>Average Cards per Hand by Enhancement</h3>
                    <table class="stats-table">
                        <tr><th>Enhancement</th><th>Total Cards</th><th>Average per Hand</th></tr>
                        ${Object.entries(stats.enhancements)
                            .sort((a, b) => b[1] - a[1])  // Sort by count descending
                            .map(([type, count]) => `
                                <tr>
                                    <td>${type}</td>
                                    <td>${count}</td>
                                    <td>${(count / totalSims).toFixed(2)}</td>
                                </tr>
                            `).join('')}
                    </table>
                `;

                // Update edition statistics
                document.getElementById('edition-stats').innerHTML = `
                    <h3>Average Cards per Hand by Edition</h3>
                    <table class="stats-table">
                        <tr><th>Edition</th><th>Total Cards</th><th>Average per Hand</th></tr>
                        ${Object.entries(stats.editions)
                            .sort((a, b) => b[1] - a[1])  // Sort by count descending
                            .map(([type, count]) => `
                                <tr>
                                    <td>${type}</td>
                                    <td>${count}</td>
                                    <td>${(count / totalSims).toFixed(2)}</td>
                                </tr>
                            `).join('')}
                    </table>
                `;

                // Update seal statistics
                document.getElementById('seal-stats').innerHTML = `
                    <h3>Average Cards per Hand by Seal</h3>
                    <table class="stats-table">
                        <tr><th>Seal</th><th>Total Cards</th><th>Average per Hand</th></tr>
                        ${Object.entries(stats.seals)
                            .sort((a, b) => b[1] - a[1])  // Sort by count descending
                            .map(([type, count]) => `
                                <tr>
                                    <td>${type}</td>
                                    <td>${count}</td>
                                    <td>${(count / totalSims).toFixed(2)}</td>
                                </tr>
                            `).join('')}
                    </table>
                `;
            } catch (error) {
                console.error('Error in simulation:', error);
                document.getElementById('sim-result').innerHTML = `
                    <div class="error-message">Error: ${error.message}</div>
                `;
            }
        }
    </script>
</body>
</html>